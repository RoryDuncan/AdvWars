// Generated by CoffeeScript 1.8.0
var Map, Selector, Tile, TileGrid, UI, Unit, currentRadian, extend, input, lines, pixels, utils;

utils = require("./_utils");

extend = utils.extend;

pixels = utils.calculatePixelPosition;

input = require("./_input");

UI = require("./_ui");

Unit = require("./_units").Unit;

Tile = function(game, name, position, size, grid) {
  this.game = game;
  this.name = name;
  this.position = position;
  this.size = size;
  this.grid = grid;
  this.Sprites = this.game.Sprites;
  this.name = this.name || "plain";
  return this;
};

Tile.prototype.render = function() {
  var size, sprite, xo, xp, xw, yo, yp, yw, zoom;
  sprite = this.Sprites[this.name];
  if (!sprite) {
    return;
  }
  size = this.size;
  zoom = this.grid.zoom;
  xo = this.grid.offset.x * size;
  yo = this.grid.offset.y * size;
  xp = this.position.x * size;
  yp = this.position.y * size;
  xw = (xo + size + xp) * zoom;
  yw = (yo + size + yp) * zoom;
  return sprite.render.call(sprite, xp + xo, yp + yo, size, size, zoom);
};

Tile.prototype.showPosition = function(xp, xo, yp, yo, size, zoom) {
  this.game.context.font = "" + (size / 4) + "px Helvetica";
  this.game.context.fillStyle = "#444";
  return this.game.context.fillText("" + this.position.x + "," + this.position.y, xp + xo + (size / 4), yp + yo + (size / 2));
};

Tile.prototype.toString = function() {
  return "[object Tile]";
};

module.exports.Tile = Tile;

TileGrid = function(game, data, dimensions) {
  var createTiles, height, tilesize, width;
  this.game = game;
  this.data = data;
  this.dimensions = dimensions;
  Tile.prototype.game = game;
  this.tiles = [];
  width = this.dimensions.width;
  height = this.dimensions.height;
  tilesize = this.dimensions.tilesize;

  /* Convert the data into a normalized grid data */
  createTiles = function(coords, i, isCenterIndex) {
    var tile, tilename;
    tilename = this.data[1] === "-all" ? this.data[0] : this.data[i];
    tile = new Tile(this.game, tilename, coords, tilesize, this);
    if (typeof isCenterIndex === "number") {
      tile.isCenter = true;
      this.centerIndex = isCenterIndex;
    }
    this.tiles.push(tile);
  };
  utils.generateNormalizedGrid(width, height, createTiles, this);
  this.offset = {};
  this.offset.origin = {};
  this.offset.x = this.offset.origin.x = ~~width;
  this.offset.y = this.offset.origin.y = ~~height;
  this.zoom = 1;
  return this;
};

TileGrid.prototype.setZoom = function(zoom) {
  if (zoom == null) {
    zoom = 1;
  }
  return this.zoom = zoom;
};

TileGrid.prototype.crossZoom = function(modifier) {
  return this.zoom = this.zoom * modifier;
};

TileGrid.prototype.move = function(x, y) {
  if (x == null) {
    x = 0;
  }
  if (y == null) {
    y = 0;
  }
  this.offset.x += x;
  this.offset.y += y;
  return this.render();
};

TileGrid.prototype.AlignToOrigin = function() {
  this.offset.origin.x = this.offset.origin.x;
  this.offset.origin.y = this.offset.origin.y;
};

TileGrid.prototype.changeTile = function(x, y, tilename) {
  return console.log("wow");
};

TileGrid.prototype.render = function() {
  return this.tiles.forEach(function(tile) {
    return tile.render.call(tile);
  });
};

module.exports.TileGrid = TileGrid;

Map = function(name, tilegrid, game, backgroundColor) {
  this.name = name;
  this.tilegrid = tilegrid;
  this.game = game;
  this.backgroundColor = backgroundColor != null ? backgroundColor : "#476ca1";
  this.centerIndex = this.tilegrid.centerIndex;
  return this;
};

Map.prototype.render = function() {
  return this.tilegrid.render.call(this.tilegrid);
};

currentRadian = 0;

lines = 90;

Map.prototype.drawBackground = function() {
  var ctx, game;
  game = this.game;
  ctx = game.context;
  ctx.fillStyle = "#6393d8";
  return ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);

  /*
   *styles
  lineWidth = game.canvas.width / (lines)
  lineColor =  @backgroundColor2 or "#6393d8"
   * to be restored afterwards
  previousStroke = game.context.strokeStyle
  
   * animation or math related
  max = 6
  pi = 22 / 7;
  rayWidth = 25
  radius = game.canvas.width
  space = (360 / lines) * (pi / 180)
  middle = { x: game.canvas.width / 2, y: game.canvas.height / 2}
  
   * The plain background color
  ctx.fillStyle = @backgroundColor
  ctx.fillRect 0, 0, game.canvas.width, game.canvas.height
  
   * the style of the line
  ctx.strokeStyle = lineColor
  for line in [0..lines]
     * draw a line
    ctx.beginPath()
    ctx.moveTo(middle.x, middle.y)
    
    calc_x = (radius * Math.sin(currentRadian + (space * line))) + middle.x
    calc_y = (radius * Math.cos(currentRadian + (space * line))) + middle.y
    ctx.lineTo(calc_x, calc_y)
    ctx.lineWidth = lineWidth;
    ctx.stroke()
    ctx.closePath()
  
   *important part
  currentRadian += 0.002
  currentRadian = (-1*max) if currentRadian > max
  
   * restorations
  ctx.globalAlpha = 1
  ctx.strokeStyle = previousStroke
   */
};

Map.prototype.getActionBindings = function() {
  var that;
  that = this;
  return {
    "keydown numpad8": that.up.bind(that),
    "keydown numpad2": that.down.bind(that),
    "keydown numpad4": that.left.bind(that),
    "keydown numpad6": that.right.bind(that)
  };
};

Map.prototype.move = function(x, y) {
  if (x == null) {
    x = 1;
  }
  if (y == null) {
    y = 1;
  }
  return this.tilegrid.move(x, y);
};

Map.prototype.up = function() {
  return this.move(0, -1);
};

Map.prototype.down = function() {
  return this.move(0, 1);
};

Map.prototype.left = function() {
  return this.move(-1, 0);
};

Map.prototype.right = function() {
  return this.move(1, 0);
};

Map.prototype.play = function() {
  var mapActionBindings, selector;
  console.log("Playing " + this.name + "!");
  this.selector = selector = new Selector(this.game, this, "select");
  this.selector.inputProfile_ = new input.InputProfile("selector-panning", this.game.inputHandler, this.selector.getActionBindings());
  this.selector.inputProfile_.enable();
  mapActionBindings = this.getActionBindings();
  this.mapPanningProfile_ = new input.InputProfile("map-panning", this.game.inputHandler, mapActionBindings);
  this.mapPanningProfile_.enable();
  return this.game.Layers.add.call(this.game, {
    name: "selector",
    layer: 6,
    fn: selector.render,
    scope: selector
  });
};

Map.prototype.disableMapKeys = function() {
  this.selectorActionProfile_.disable();
  this.mapPanningProfile_.disable();
  return this;
};

Map.prototype.edit = function() {
  return console.log("Editing " + this.name + "!");
};

module.exports.Map = Map;

Selector = function(game, map, type) {
  var src;
  this.game = game;
  this.map = map;
  this.type = type != null ? type : "select";
  this.Sprites = this.game.Sprites;
  this.centerIndex = this.map.centerIndex;
  this.grid = this.map.tilegrid.tiles;
  src = this.grid[this.centerIndex].position;
  this.position = extend({}, src);
  this.map.selector = this;
  this.menu = new UI.Menu(this.game, "selector-actions");
  return this;
};

Selector.prototype.select = function() {
  var selected;
  selected = this.getGameObjectsHere();
  if (selected[0] instanceof Unit) {
    console.log(selected[0]);
    this.menu.on("open", this.inputProfile_.disable.bind(this.inputProfile_));
    this.menu.on("close", this.inputProfile_.enable.bind(this.inputProfile_));
    this.menu.compile(this.unitActions());
    return this.menu.open();
  }
};

Selector.prototype.unitActions = function() {
  var that;
  that = this;
  return {
    "move": utils.noop,
    "attack": utils.noop,
    "info": utils.noop,
    "close": that.menu.close
  };
};

Selector.prototype.getGameObjectsHere = function() {
  var selected, tile, unit;
  selected = [];
  unit = this.getUnitAt(this.position);
  tile = this.getTile();
  if (unit) {
    selected.push(unit);
  }
  if (tile === void 0) {
    throw new Error("Selector Grabbed Out of Bounds");
  }
  selected.push(tile);
  return selected;
};

Selector.prototype.getIndexOf = function(position) {
  var index;
  if (position == null) {
    position = {
      x: 0,
      y: 0,
      id: 0
    };
  }
  index = null;
  this.grid.forEach(function(el, i) {
    if (el.x === position.x && el.y === position.y) {
      return index = i;
    }
  });
  return index;
};

Selector.prototype.getIndex = function() {
  return this.position.id || 0;
};

Selector.prototype.getTile = function() {
  return this.grid[this.getIndex()];
};

Selector.prototype.getUnitAt = function(position) {
  if (!this.game.UnitManager) {
    return {};
  }
  return this.game.UnitManager.getUnitAt(position);
};

Selector.prototype.isOutOfBounds = function(move) {
  var amount, dimensions, isOutOfBounds, outOfBounds, tg;
  if (move == null) {
    move = true;
  }
  outOfBounds = false;
  tg = this.map.tilegrid;
  dimensions = pixels(tg.dimensions.tilesize, this.position, tg.offset, tg.zoom);
  amount = 2;
  if (move) {
    if (dimensions.x < 0) {
      this.map.move.call(this.map, amount, 0);
      isOutOfBounds = true;
    } else if (dimensions.endx > window.innerWidth) {
      this.map.move.call(this.map, -amount, 0);
      isOutOfBounds = true;
    }
    if (dimensions.y < 0) {
      this.map.move.call(this.map, 0, amount);
      isOutOfBounds = true;
    } else if (dimensions.endy > window.innerHeight) {
      this.map.move.call(this.map, 0, -amount);
      isOutOfBounds = true;
    }
  } else {
    if (dimensions.x < 0) {
      return true;
    } else if (dimensions.endx > window.innerWidth) {
      return true;
    }
    if (dimensions.y < 0) {
      return true;
    } else if (dimensions.endy > window.innerHeight) {
      return true;
    }
  }
  return isOutOfBounds;
};

Selector.prototype.move = function(x, y) {
  this.position.x += x;
  this.position.y += y;
};

Selector.prototype.getActionBindings = function() {
  var that;
  that = this;
  return {
    "keydown up": this.moveUp.bind(that),
    "keydown down": this.moveDown.bind(that),
    "keydown left": this.moveLeft.bind(that),
    "keydown right": this.moveRight.bind(that),
    "keydown enter": this.select.bind(that)
  };
};

Selector.prototype.moveUp = function() {
  var p;
  p = this.position;
  p.y = utils.limitToRange(p.y - 1, p.start.y, p.end.y);
  return this.isOutOfBounds();
};

Selector.prototype.moveDown = function() {
  var p;
  p = this.position;
  p.y = utils.limitToRange(p.y + 1, p.start.y, p.end.y);
  return this.isOutOfBounds();
};

Selector.prototype.moveLeft = function() {
  var p;
  p = this.position;
  p.x = utils.limitToRange(p.x - 1, p.start.x, p.end.x);
  return this.isOutOfBounds();
};

Selector.prototype.moveRight = function() {
  var p;
  p = this.position;
  p.x = utils.limitToRange(p.x + 1, p.start.x, p.end.x);
  return this.isOutOfBounds();
};

Selector.prototype.render = function() {
  var ctx, dimensions, ls, tg;
  ls = 1;
  tg = this.map.tilegrid;
  dimensions = pixels(tg.dimensions.tilesize, this.position, tg.offset, tg.zoom);
  ctx = this.game.context;
  ctx.strokeStyle = this.color || "#eee";
  ctx.lineWidth = ls;
  return ctx.strokeRect(dimensions.x - ls, dimensions.y - ls, dimensions.size + ls, dimensions.size + ls);
};

module.exports.Selector = Selector;
