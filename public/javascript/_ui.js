// Generated by CoffeeScript 1.8.0
var $, $meth, Dialogue, EventEmitter, Manager, Menu, extend, input, isSubject, method, methodizer, pixels, utils;

utils = require("./_utils");

input = require("./_input");

extend = utils.extend;

pixels = utils.calculatePixelPosition;

EventEmitter = utils.EventEmitter;

$ = require("jquery");


/*
  @NAME Dialogue
  @DESCRIPTION Returns an object for rendering text to the Canvas
  @PAREMS Passed in as options object
    @options,data: object
 */

Dialogue = function(game, options) {
  this.game = game;
  this.data = {
    text: {
      color: "#fff",
      size: "14px",
      family: "Helvetica",
      value: ""
    },
    heading: {
      color: "#fff",
      size: "20px",
      family: "Helvetica",
      value: ""
    }
  };
  this.position = {
    x: -1,
    y: -1,
    absolute: true,
    calc: {
      x: 0,
      y: 0
    }
  };
  this.separator = "|";
  this.id = utils.UID("dialogue", true);
  this.visible = true;
  this.has = {};
  return extend(this, options);
};

extend(Dialogue.prototype, EventEmitter.prototype);

Dialogue.prototype.verify = function() {};

Dialogue.prototype.heading = function(value, size, color, family) {
  this.has.heading = true;
  this.data.heading.size = size || this.data.heading.size;
  this.data.heading.color = color || this.data.heading.color;
  this.data.heading.family = family || this.data.heading.family;
  this.data.heading.value = value;
  return this;
};

Dialogue.prototype.text = function(text, size, color, family) {
  this.has.text = true;
  this.data.text.size = size || this.data.text.size;
  this.data.text.color = color || this.data.text.color;
  this.data.text.family = family || this.data.text.family;
  this.data.text.value = text;
  return this;
};

Dialogue.prototype.drawBorder = function(color) {
  this.has.border = true;
};

Dialogue.prototype.drawBackground = function(color) {
  this.has.background = true;
};

Dialogue.prototype.hide = function() {
  this.visible = false;
  return this;
};

Dialogue.prototype.show = function() {
  this.visible = true;
  return this;
};

Dialogue.prototype.toggle = function() {
  this.visible = !this.visible;
  return this;
};

Dialogue.prototype.relativeTo = function(obj) {
  this.attachedTo = obj;
  this.tilegrid = obj.tilegrid || obj.map.tilegrid;
  this.getRelativePositions();
  return this.position.absolute = false;
};

Dialogue.prototype.getRelativePositions = function() {
  var a, dimensions, p;
  a = this.attachedTo;
  p = {
    x: this.position.x + a.position.x,
    y: this.position.y + a.position.y
  };
  dimensions = pixels(this.tilegrid.dimensions.tilesize, p, this.tilegrid.offset, this.tilegrid.zoom);
  this.position.calc.x = dimensions.x;
  return this.position.calc.y = dimensions.y;
};

Dialogue.prototype.getFont = function(type) {
  var family, size;
  size = parseFloat(this.data[type].size);
  family = this.data[type].family;
  return "" + size + "px " + family;
};

Dialogue.prototype._renderHeading = function() {
  var ctx, font;
  font = this.getFont("heading");
  ctx = this.game.context;
  ctx.fillStyle = this.data.heading.color;
  ctx.font = font;
  ctx.fillText(this.data.heading.value, this.position.calc.x || this.position.x, this.position.calc.y || this.position.y);
  return parseFloat(this.data.heading.size);
};

Dialogue.prototype._renderLines = function() {
  var ctx, family, i, line, lines, margin, marginTop, size, x, y, _i, _len, _results;
  lines = this.data.text.value.split(this.separator);
  margin = 2;
  marginTop = 0;
  if (this.has.heading) {
    marginTop = this._renderHeading();
  }
  x = this.position.calc.x || this.position.x;
  y = this.position.calc.y || this.position.y;
  ctx = this.game.context;
  ctx.fillStyle = this.data.text.color;
  size = parseFloat(this.data.text.size);
  family = this.data.text.family;
  ctx.font = "" + size + "px " + family;
  _results = [];
  for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
    line = lines[i];
    _results.push(ctx.fillText(lines[i], x, marginTop + y + i * (margin + size)));
  }
  return _results;
};

Dialogue.prototype.render = function() {
  var ctx, marginTop;
  if (!this.visible) {
    return;
  }
  if (!this.position.absolute) {
    this.getRelativePositions();
  }
  if ((this.data.text.value.split(this.separator)).length > 1) {
    this._renderLines();
    return;
  }
  marginTop = 0;
  if (this.has.heading) {
    marginTop = this._renderHeading();
  }
  ctx = this.game.context;
  ctx.fillStyle = this.data.text.color || "#000";
  ctx.font = this.getFont("text");
  ctx.fillText(this.data.text.value, this.position.calc.x || this.position.x, marginTop + (this.position.calc.y || this.position.y));
};

module.exports.Dialogue = Dialogue;


/*
    Menu
 */

Menu = function(game, id, options) {
  this.game = game;
  this.id = id;
  if (options == null) {
    options = {};
  }
  this.noop = new Function();
  this.deferred = this.noop;
  this.callbackContext = null;
  this.classname = options.classname || "list";
  this.position = {
    x: 0,
    y: 0
  };
  this.active = 0;
  this.$el = $("#" + this.id);
  this.map;
  if (options.data) {
    this.compile(options.data);
  }
  if (options.css) {
    this.applyCSS(options.css);
  }
  return this;
};

extend(Menu.prototype, EventEmitter.prototype);

Menu.prototype.css = function(obj) {
  if ($("#" + this.id).length === 0) {
    console.warn("Delegated applying css. Compile to apply.", obj);
    this.deferred = function() {
      return $("#" + this.id).css(obj);
    };
  } else {
    $("#" + this.id).css(obj);
  }
  return this;
};

Menu.prototype.animate = function(obj) {
  return $("#" + this.id).animate(obj);
};

Menu.prototype.getPosition = function() {
  var bottom, left, right, top, x, y;
  top = $("#" + this.id).css("top");
  left = $("#" + this.id).css("left");
  right = $("#" + this.id).css("right");
  bottom = $("#" + this.id).css("bottom");
  if (top !== "auto") {
    y = parseFloat(top, 10);
  }
  if (left !== "auto") {
    x = parseFloat(left, 10);
  }
  if (right !== "auto") {
    x = -1 * parseFloat(right, 10);
  }
  if (bottom !== "auto") {
    y = -1 * parseFloat(bottom, 10);
  }
  x = x || 0;
  x = x || 0;
  console.log({
    top: top,
    right: right,
    bottom: bottom,
    left: left
  });
  return {
    x: x,
    y: y
  };
};

Menu.prototype.compile = function(obj) {
  var count, footer, header, key, li, listItems, value, _ref;
  console.log(obj);
  this.data = obj || this.data || {};
  this.names = [];
  this.active = this.active || 0;
  count = 0;
  header = "<div id='" + this.id + "' class='" + this.classname + "'><ul>";
  listItems = "";
  footer = "</ul></div>";
  li = function(text, id) {
    var isActive;
    if (text.slice(0, 2) === "__") {
      return "";
    }
    isActive = (count === this.active ? " class='active' " : "");
    count++;
    return "<li> <a href='#' " + isActive + " data-name='" + text + "'> " + text + " </a></li>";
  };
  _ref = this.data;
  for (key in _ref) {
    value = _ref[key];
    if (key === "length") {
      continue;
    }
    listItems += li.call(this, key, this.id);
    if (typeof value !== "function") {
      this.data[key] = this.noop;
    }
    this.names.push(key);
  }
  this.length = count;
  this.compiledString = header + listItems + footer;
  this.compiledListItems = listItems;
  return this;
};

methodizer = function($method, isSubject) {
  if (isSubject == null) {
    isSubject = true;
  }
  if (isSubject) {
    return function(selector) {
      this.exists = true;
      return $(this.compiledString)[$method](selector);
    };
  } else {
    return function(selector) {
      this.exists = true;
      return $(selector)[$method](this.compiledString);
    };
  }
};

$meth = {
  "append": false,
  "before": false,
  "html": false,
  "after": false,
  "appendTo": true
};

for (method in $meth) {
  isSubject = $meth[method];
  if (Menu.prototype[method] !== void 0) {
    return console.warn("Menu.p." + method + " is not undefined.");
  }
  Menu.prototype[method] = methodizer(method, isSubject);
}

Menu.prototype.update = function() {
  this.compile(this.data);
  $("#" + this.id + " ul").html(this.compiledListItems);
  return this;
};

Menu.prototype.render = function(selector) {
  this.selector = selector;
  if (this.exists) {
    return this.update();
  }
  this.html(this.selector);
  this.deferred.call(this);
  this.deferred = this.noop;
  return this;
};

Menu.prototype.add = function(name, callback) {
  this.data[name] = callback || this.noop;
  this.update();
  return this;
};

Menu.prototype.remove = function(name) {
  this.data[name] = void 0;
  delete this.data[name];
  this.update();
  return this;
};

Menu.prototype.hide = function(name) {
  var callback;
  if (name === void 0) {
    $("#" + this.id).hide();
    return this;
  }
  callback = this.data[name];
  if (!callback) {
    return this;
  }
  delete this.data[name];
  this.add("__" + name, callback);
  return this;
};

Menu.prototype.show = function(name) {
  var callback;
  if (name === void 0) {
    $("#" + this.id).show();
    return this;
  }
  callback = this.data["__" + name];
  if (!callback) {
    return this;
  }
  delete this.data["__" + name];
  this.add(name, callback);
  return this;
};

Menu.prototype.destroy = function() {
  console.log("Destruction Imminent");
  $("#" + this.id).remove();
};

Menu.prototype.next = function() {
  var current;
  if (this.active === this.length - 1) {
    this.active = 0;
  } else {
    this.active += 1;
  }
  $("#" + this.id + " li a").removeClass("active");
  current = $("#" + this.id + " li a")[this.active];
  return $(current).addClass("active");
};

Menu.prototype.prev = function() {
  var current;
  if (this.active === 0) {
    this.active = this.length - 1;
  } else {
    this.active -= 1;
  }
  $("#" + this.id + " li a").removeClass("active");
  current = $("#" + this.id + " li a")[this.active];
  return $(current).addClass("active");
};

Menu.prototype.select = function(e) {
  var name;
  name = this.names[this.active];
  return this.data[name].call(this.callbackContext || this, name, this, e);
};

Menu.prototype.selectedElement = function() {
  return $("#" + this.id + " li a.active");
};

Menu.prototype.getActionBindings = function() {
  var that;
  that = this;
  return {
    "keydown up": that.prev.bind(that),
    "keydown down": that.next.bind(that),
    "keydown enter": that.select.bind(that)
  };
};

Menu.prototype.open = function() {
  var menuProfile_;
  this.trigger("open");
  this.render(this.selector || ".menu").show();
  this.profile_ = menuProfile_ = this.profile_ || new input.InputProfile("menu-navigation", this.game.inputHandler, this.getActionBindings());
  this.profile_.enable();
  return this;
};

Menu.prototype.close = function() {
  if (!this.profile_) {
    return;
  }
  console.log("closing");
  this.profile_.disable();
  this.trigger("close");
  return this.hide();
};

module.exports.Menu = Menu;


/*
  @name Manager
  The object to manage instances of 'Dialogue' or 'Menu',
  and makes sure they get rendered.
 */

Manager = function(game) {
  this.game = game;
  this.list = [];
  this.menus = [];
  this.game.Layers.add({
    name: "UserInterface",
    layer: 7,
    fn: this.render,
    scope: this
  });
  return this;
};

extend(Manager.prototype, EventEmitter.prototype);

Manager.prototype.Dialogue = function(options) {
  var length;
  length = this.list.push(new Dialogue(this.game, options));
  return this.list[length - 1];
};

Manager.prototype.Menu = function(name, options) {
  var menu;
  menu = new Menu(this.game, name, options);
  this.menus.push(menu);
  return menu;
};

Manager.prototype.render = function() {
  var item, _i, _len, _ref, _results;
  _ref = this.list;
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    item = _ref[_i];
    _results.push(item.render.call(item));
  }
  return _results;
};

module.exports.Manager = Manager;
